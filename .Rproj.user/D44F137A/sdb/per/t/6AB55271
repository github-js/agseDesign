{
    "collab_server" : "",
    "contents" : "#' @export\n#' @importFrom msm ptnorm\n\noperatingChar <-function(alpha,information.fraction,th1,th2,int.l1,int.u1,int.l2,int.u2,f1){\n\n\n  myresults <- list()\n\n  t=information.fraction\n  alpha.Star<-(alpha*alpha)\n  au1.Star<-alpha.Star*t\n  al1.Star<-(1-alpha.Star)*t\n\n  au2.Star<-alpha.Star*(1-t)\n  al2.Star<-(1-alpha.Star)*(1-t)\n\n\n  Stage1.Limits.Opt <- optim(c(int.l1,int.u1),\n                             Stage1.Boundary.Values,\n                             D=c(1,1,1,1),\n                             th1=c(0,0),\n                             th2=c(0,0),\n                             au=au1.Star,\n                             al=al1.Star,\n                             optimize=T,\n                             method=\"Nelder-Mead\",\n                             control=list(maxit=1000))\n\n  # For now I am keeping int.l1 and int.u1 in the above function just for checking different values.\n  # Once we decidie which initial value we use, we will replace these two variables by those\n  # values, otherwise giving users option to use different values will create complexity\n\n  Limits.1<-cbind(Stage1.Limits.Opt$par[1],Stage1.Limits.Opt$par[2])\n  myresults$Stage1.Limits <- as.vector(Limits.1)\n  names(myresults$Stage1.Limits) <- c('Lower Limit','Upper Limit')\n\n  Stage2.Limits.Opt <- optim(c(int.l2,int.u2),\n                             Stage2.Boundary.Values,\n                             lims1=c(Stage1.Limits.Opt$par[1],Stage1.Limits.Opt$par[2]),\n                             th1=c(0,0),\n                             th2=c(0,0),\n                             D=c(1,1,1,1),\n                             Ds2=c(1,1,1,1),\n                             au2=au2.Star,\n                             al2=al2.Star,\n                             optimize=T,\n                             method=\"Nelder-Mead\",\n                             control=list(maxit=1000))\n\n  # The same will apply for int.l2 and int.u2\n  # We may also need to make sure these two values are not more than the value of Stage1.Limits.Opt$par[2]\n  # Jae: Can you please think about an option to write the code so that this value does not exceed\n  # the upper limit of the previous stage I upper limit, that is Stage1.Limits.Opt$par[2].\n\n  Limits.2<-cbind(Stage2.Limits.Opt$par[1],Stage2.Limits.Opt$par[2])\n  myresults$Stage2.Limits <- as.vector(Limits.2)[1]\n  names(myresults$Stage2.Limits) <- c('Upper Limit')\n\n  # Computation of estimated stage1 information under th1=(1,1) and th2=(1,1)\n  D1.Hat <- optim(c(1,1,1,1),\n                  Stage1.Inf.Optimization,\n                  a=Limits.1[1],b=Limits.1[2],\n                  th1=c(1,1),th2=c(1,1),\n                  optimize=T,method=\"Nelder-Mead\",control=list(maxit=1000))\n  #myresults$D1.Hat <- matrix(D1.Hat[[1]],ncol=2)\n\n  # Computation of estimated stage2 information under th1=(1,1) and th2=(1,1) and D1.Hat\n  # Should we use D1.Hat in the estimation of D2.Hat or use D=c(1,1,1,1)?\n  D2.Hat<-optim(c(1,1,1,1),\n                Stage2.Inf.Optimization,\n                lims2=c(Limits.2[1],Limits.2[2]),\n                lims1=c(Limits.1[1],Limits.1[2]),\n                th1=c(1,1),th2=c(1,1),\n                D=c(D1.Hat$par[1],D1.Hat$par[3],D1.Hat$par[2],D1.Hat$par[4]),\n                optimize=T,\n                method=\"Nelder-Mead\",\n                control=list(maxit=1000))\n  #myresults$D2.Hat <- matrix(D2.Hat[[1]],ncol=2)\n\n  # Computation of total estimated information\n  D.Hat<-sum(D1.Hat$par)+sum(D2.Hat$par)\n\n  # Stage1 subgroup specific information at information time t\n  # Total informationxinformation timexsubgroup prevalence\n\n  Stage1.S1.D.Hat<-D.Hat*t*f1\n  Stage1.S2.D.Hat<-D.Hat*t*(1-f1)\n\n  # New estimated information for stage 1\n  New.D1.Hat<-cbind(Stage1.S1.D.Hat/2,Stage1.S1.D.Hat/2,Stage1.S2.D.Hat/2,Stage1.S2.D.Hat/2)\n\n  # Stage 1 power under th1=(1,1),th2=c(1,1)\n  # Changing the values of th1 and th2 below we can get stage 1 power for different efficacy setting\n  Stage1.Power <- Stage1.Boundary.Values(lims1=c(Limits.1[1],Limits.1[2]),\n                                         D=c(New.D1.Hat[1],New.D1.Hat[2],New.D1.Hat[3],New.D1.Hat[4]),\n                                         th1=th1,th2=th2,\n                                         au=au1.Star,al=al1.Star,optimize=F)\n\n  # Stage 2 power under th1=(1,1),th2=c(1,1)\n  # Changing the values of th1 and th2 below we can get stage 1 power for different efficacy setting\n\n  Stage2.Power <- Stage2.Boundary.Values(lims2=c(Limits.2[1],Limits.2[2]),\n                                         lims1=c(Limits.1[1],Limits.1[2]),\n                                         th1=th1,th2=th2,\n                                         D=c(New.D1.Hat[1],New.D1.Hat[2],New.D1.Hat[3],New.D1.Hat[4]),\n                                         Ds2=c(New.D1.Hat[1],New.D1.Hat[2],New.D1.Hat[3],New.D1.Hat[4]),\n                                         au2=au2.Star,al2=al2.Star,optimize=F)\n\n  # For same values of th1 and th2, if we add Stage1 and stage 2 power, we will get the\n  # final table in the manuscript which provides rejection probabilities.\n\n  myresults$Stage1.OC <- c(Stage1.Power$OR,\n                           Stage1.Power$S1,\n                           Stage1.Power$S2,\n                           Stage1.Power$TR)\n\n  myresults$Stage2.OC <- c(Stage2.Power$OR,\n                           Stage2.Power$S1,\n                           Stage2.Power$S2,\n                           Stage2.Power$TR)\n\n  myresults$Overall.OC <- c((Stage1.Power$OR + Stage2.Power$OR),\n                            (Stage1.Power$S1 + Stage2.Power$S1),\n                            (Stage1.Power$S2 + Stage2.Power$S2),\n                            (Stage1.Power$TR + Stage2.Power$TR))\n\n  names(myresults$Stage1.OC) <- c('Rejection probability overall',\n                                  'Rejection probability subgroup 1',\n                                  'Rejection probability subgroup 2',\n                                  'Total rejection probability')\n\n  names(myresults$Stage2.OC) <- c('Rejection probability overall',\n                                  'Rejection probability subgroup 1',\n                                  'Rejection probability subgroup 2',\n                                  'Total rejection probability')\n\n  names(myresults$Overall.OC) <- c('Rejection probability overall',\n                                   'Rejection probability subgroup 1',\n                                   'Rejection probability subgroup 2',\n                                   'Total rejection probability')\n\n  return(myresults)\n}\n",
    "created" : 1552193730659.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3258887421",
    "id" : "6AB55271",
    "lastKnownWriteTime" : 1552194726,
    "last_content_update" : 1552194726175,
    "path" : "Z:/My documents/1packages/agseDesign/R/operatingChar.R",
    "project_path" : "R/operatingChar.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}